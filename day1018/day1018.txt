<접근명시자의 종류>
private
자기자신 이외의 모든 클래스로부터 보호됨

(default) = friendly
자신이 포함된 패키지까지는 접근 허용
접근제어자가 명시되어 있지않은 경우가 모두 default 명시자임

protected
자신이 포함된 패키지는 물론
다른 패키지의 상속받은 자식클래스까지 접근 허용

public
누구에게나 열려있음
모두가 접근할 수 있음
-=========================================================

<추상메서드와 추상클래스>
추상클래스는
구현부(body)가 없는 추상메서드를 가진 클래스
클래스 내에
추상클래스가 단 하나라도 있다면
클래스 앞에 "abstract" 키워드를 붙혀주어야한다.

추상클래스의 추상메서드들은
추상클래스를 상속받은 자식클래스들이
무조건 구현부를 만들어주어야한다.
(= 온전한 메서드로 만들어주어야한다.)
 -> 상속받은 자식클래스는 추상메서드를 무조건 메서드 오버라이딩 해주어야한다.

또한,
추상클래스는
온전하지않은 추상메서드를 가지고 있기때문에
객체생성이 불가하다!

메서드가 온전해질때
즉, 추상메서드가 오버라이딩 되었을 때
클래스의 객체를 생성할 수 있다.

ex)
(부모클래스 타입) 참조변수이름 = new (자식클래스타입)
-> 이것은 가능하다.
왜냐 가리키고 있는 자식클래스가 메서드오버라이딩을 통하여
추상메서드를 온전한 메서드로 만들어주었기때문에

Why? 추상메서드가 필요할까?
미래에 자식클래스가 가져야 할 속성과 동작을 일반화 함에 있어서
해당 동작은 해당부모의 자식클래스들이 반드시 모두 가져야할 동작(메서드)인데
당장 부모클래스에서는 구체화할 수 없는 메서드일 경우
추상메서드로 만듦으로써
모든 자식클래스들이 추상메서드를 오버라이딩을 의무적 조건으로 달기 위해서 만듦

*
미래에 만들어지는 자식클래스들이 가져야 할 공통적인 속성과 동작들을 모아서 부모클래스를 만드는데
이것을 미래에 후손 클래스들이 가져야 할 속성과 동작들을 "일반화 한다"라고 함

*
이클립스에서 클래스명을 잘못입력했거나, 변경하고 싶을 때
Package Explore에서 바꾸고자 하는 클래스명을 선택 ->
마우스 우 클릭 -> Refacter -> Rename -> 이름 변경

파일명도 바뀌면서 클래스 명도 함께 바뀌고 이 클래스를 사용하던 모든 소스코드에서도 한꺼번에 변경시켜줌

======================================================================================================

<instanceof 연산자>
객체타입을 형변환 할 수 있는지에 대하여
boolean값으로 알려주는 연산자.

================================================================================================

<final>
1. final + 변수명
일반적인 멤버변수는
필요에 따라 값 변경이 가능하다.

하지만,
final이 붙은 멤버변수는 상수로 취급되며
한번 값이 정해지면 그 값을 변경할 수 없다

문자열 데이터 또한, 상수이다.

이렇게 어차피 추후에 변경하지 못하는 변수들은
따로따로 메모리를 확보할 필요없이, 단 하나의 메모리에 저장하여 같이 사용하도록 "static"으로 만든다.
-> 한번만 받아들이고 다 배척!

*final 변수는 다른 일반속성과 구별되기 위하여
모두 대문자로 이름을 작성한다!

2.final + 멤버메소드이름
일반적으로 메소드들은
오버라이딩을 통하여 각자의 클래스에 맞게 변경이 가능했다.

하지만,
final이 붙은 메서드는 오버라이딩을 할 수 없다.
-> 고집불통, 변화하지않을 거임

3.final + 클래스
일반적인 클래스들은
확장(상속)하여 새로운 클래스를 만들 수 있다.

하지만,
final이 붙은 클래스는
더 이상 확장(상속)할 수 없다
-> 불임으로 만들어버림

================================================================
자바 - 다중상속 금지

한 클래스가 두개 이상의 클래스를 상속받을 수 없다.
이는,
다중상속시에 겹쳐지는 메서드들에 대한 혼란을 막고자 그렇다.

인터페이스는
다중상속이 줄 수 있는 장점만을 갖기 위해 사용된다.

<인터페이스>
클래스를 정의 하듯이
interface 인터페이스이름 {

}
으로 만들어 진다.
-> 새로운 자료형의 개념

인터페이스 == "완전추상"의 개념
인터페이스의 {}안에 들어갈 수 있는 것은
상수 or 추상메서드 이다.

앞서,
상수라는 것을 나타내기위해 final + 변수명으로 작성한다 했는데
인터페이스라는 것 자체가 완전 추상이기 때문에
final을 붙이지 않아도 자동 final이며
메서드이름 앞에 abstract를 붙이지 않아도 자동 abstract이다
->변수나 메서드앞에 상수키워드, 추상키워드 작성할 필요가없다.

<인터페이스를 구현하는 클래스>
class 클래스명 implements 부모인터페이스이름{
}
그리고 당연하게도
인터페이스의 메서드는
자식클래스가 무조건 오버라이딩해주어야함

또한,
여러개의 부모인터페이스를 하나의 클래스가 가질 수 도 있음
구분자는 ","
ex)
class A implements K, C{}
->모든 인터페이스의 메서드는 오버라이딩 해주어야 한다.