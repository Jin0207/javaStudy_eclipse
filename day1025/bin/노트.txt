Iterator(반복자)
 데이터가 있는 만큼 반복 수행하기 위한 클래스
 -----------------------------------------------------
 왜 인터페이스를 사용해서 자식클래스들을 이용하는가
  일처리 메서드를 하나로 통일시키기 위해서
  
  소스파일이름을 변경햇다고 .class가 만들어지진않음
  enter후에 저장하면 만들어지니 꼭 변경하였으면 enter하고 저장
  
 -----------------------------------------------------
 예외처리
 	프로그램 실행 중에 예기치 않는 상황이 발생하는 것을 "예외"라고 한다
 	이러한 예외를 처리하는 것을 "예외처리"라고 한다
 	
 	자바에서는 대부분으 ㅣ예기치 않은 상황에 대해서 이미 클래스로만들어져있고
 	그 예기치 않은 상황이 되면
 	자동으로
 	예외 객체를 생성한다
 	
 	예를 들어,
 	어떤 수를 0으로 나누려고
 	다음과 같은 문장을 만나면
 	int a = 4/0;
 	
 	자바가 자동으로 new ArithmeticException() 객체를 생성한다.
 	
 	이와같이 일반적으로 발생할 수 있는 예외에 대해서는
 	자바가 이미 클래스를 만들어 놓았고
 	그러한 상황이 되면, 자동으로 "예외 객체"가 생성이 된다.
 	
 	예외처리를 하기 위한 기본방식은
 	다음과 같이 예외가 발생이 될만한 문장들을 try{ }안에 작성해주고
 	예외가 발생되었을 때 처리할 문장을 catch(예외클래스명 변수명){ }안에 작성
 	
 	하나의 try 안에 여러개의 catch 절이 올 수 있다.
 	이때 catch절의 순서는 범위가 작은 예외클래스 순서대로 와야한다.
 	
 	예외가 발생하든 정상 동작하든, 반드시 처리해야할 명령이 있다면
 	"finally"를 사용한다.
 	try{
 	  //예외 발생이 예상되는 문장
 	}catch(예외클래스명1 변수명){
 		//예외발생 시 예외를 처리할 문장
 	}catch(예외클래스명2 변수명){
 		//예외발생 시 예외를 처리할 문장
 	}finally{
 		//반드시 try문장이 실행될 때, 처리해야할 명령어(들)
 	}
 ===============================================================
 
 <예외와 관련하여 학습할 내용>
 
 throws
 throw
 RuntimeException
 사용자정의 예외
 -------------------------------------------------------------
 
 throws
 	만약, 어떤 메서드안에서 예외가 발생할 만한 명령어(들)이 있다면
 	메서드 내용과 예외처리를 작성하다보면 메소드가 길어짐
 	그래서 메서드 안에는 메서드처리를 위한 핵심내용만 쓰고
 	예외처리는 메서드를 호출하는 쪽에다가 맡기고 싶을 때
 	
 	throws 키워드를 사용
 	예외를 메서드 호출하는 쪽으로 던진다!
 	
 	이 키워드는 메서드 이름 뒤에다가 써준다.
 	
 	ex)
 	public void 메서드이름() throws 예외클래스이름{
 	
 	}
 	
 	위와 같은 메서드를 사용하려면
 	메서드를 호출하는 쪽에서 try ~catch로 예외처리를 해야한다.
 	
RuntimeException
	예외와 관련하여 제일 조상 클래스는 Exception 클래스
	Exception 클래스의 후손클래스들 중
	RuntimeException의 후손 클래스들은
	사용자가 특별히 예외처리를 하지 않아도, 자바가 예외처리를 자동으로 해줌
	하지만
	RuntimeException의 후손이 아닌 예외들은
	반드시 사용자가 예외처리를 해주어야한다.
	
	입출력과 관련한 클래스들을 모아 놓은 java.io 패키지,
	네트워크 통신과 관련한 클래스들을 모아 놓은 java.net 패키지,
	데이터베이스 연결과 관련한 클래스들을 모아 놓은 java.sql 패키지의
	대부분의 생성자 및 메서드들은 예외를 포함하고 있으며,
	그 예외들은 모두 RuntimeException의 후손이 아닙니다.
	
	따라서 세가지 패키지를 사용하려면 사용자가 반드시 예외처리를 해야한다.

자바의 예외들 중에
RuntimeException의 하위 예외들은 사용자가 예외처리를 따로 해주지 않아도 컴파일 된다.
즉, 자바가 예외처리를 자동적으로 해준다.

반면,
RuntimeException의 하위 예외가 아닌 예외들은
사용자가 반드시 예외처리를 해야 컴파일된다.
	java.io // 입출력관련
	java.net // 네트워크 통신 관련
	java.sql //데이터베이스 연결 관련
	의 대부분의 생성자와 메서드들은 RuntimeException의 하위 예외가 아닌
	예외들을 포함하고 있으니 반드시 예외처리를 해야한다.

----------------------------------------------------------------------

throw
	자바는 대부분 일반적인 예외상황에 대해서는 이미 클래스가 만들어져 있고
	그 상황이 되면 자동으로 예외 객체가 생성됨.
	
	만약, 사용자가 강제로 예외를 발생시켜야야한다면
	throw를 사용한다.
	
	사용방법
	throw new 예외클래스이름();

-----------------------------------------------------------------

사용자정의 예외
	자바는 대부분의 일반적인 예외상황에 대해서는 이미 예외클래스들이 만들어져 있고,
	그런 상황이 되면 자동으로 예외객체가 생성된다.
	
	그러나,
	내가 만들고 있는 프로젝트에서만 처리되는 특수한 상황을 예외로 만들고자 한다면,
	(즉, 자바는 모르는 어떠한 상황이 있다면)
	사용자가 직접 예외를 만들 수 있다.
	
	사용자 정의 예외클래스 만드는 법
	예외클래스들의 제일 조상인 Exception을 상속받아 클래스를 만든다.
	특별히 해 줄 것은 없고 생성 시에 예외 메세지를 전달받아 부모생성자에게 전달만 해주면 된다.
	
	사용자정의 예외는 자바가 알고있는 예외상황이 아니므로 강제로 예외를 발생시켜야한다.
	
	class 사용정의예외클래스이름 extends Exception{
		public 사용자정의예외클래스이름(String msg){
			super(msg);
		}
	}
	
	if( 문제의상황인지 조건식 ){
		throw new 사용자정의예외클래스이름("메세지");
	}	
	
	여태껏 우리는 문제의 상황을 if조건식에 물어보고
	적절한 메세지를 출력하여 처리하였다.
	이것도 좋은 방법이긴 하나,
	우리의 프로젝트에서는 미리 이러이러한 상황은 "문제로 인식하자"라고 인지하는 것이 의미가 있다.
	